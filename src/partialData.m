classdef partialData
    %PARTIALDATA Contains data important for partial calculations
    %   Class to be used on partial calculations. It contains the
    %   information of the partial area (rectangular or not) and the grains
    %   that are locaded inside it.
    
    properties
        %Rectangle description
        AngleRotation   %Rotation of the origin of the rectangle
        RectPos         %Position of rectangle used in calculations
        RotationMatrix  %Passage matrix betewen the normal axes and those inclined by 'AngleRotation'
        Vertices        %Position of the vertices of the rectangle
        Xlimit          %X Width of the piston, on 3D if choice of partial in this direction also
        
        %Grains listing
        AllGrains       %At least some part of the grain inside selected area
        GrainsInt       %Grains entirely inside the selected area
        GrainsRectangle %Grain's center inside the selected area
        
        %Subdivision
        SubGrains       %ID of grains with center inside the subdivision
        SubGrainsI      %ID of grains compleately inside the subdivision
        SubGrainsA      %ID of grains partially inside the subdivision
        SubCol          %number of subdivision colums
        SubH            %subdivision height
        SubL            %subdivision length
        SubLin          %number of subdivision lines
        SubPoint        %'main point' of each subdivision
        SubVertices     %vertices of each subdivision
    end
    methods
        %Calling function
        function PD = partialData(mode,PartData,app,varargin)
            %In the function we will have diferent ways to create a partial
            %data. From rectangles to surfaces generated by choosing
            %points. To take that into account we will look for keywords
            %that were put inside the arguments ant act properly.
            if ~isempty(PartData);PD=PartData;end
            doVert=1;
            switch upper(mode)
                case 'DATA'     %create a new object using given data
                    PD.RectPos=varargin{1};
                    PD.Xlimit=varargin{2};
                    alpha=varargin{3};
                    if nargin==7
                        PD.Vertices=varargin{4};
                        doVert=0;
                    end
                case 'LOAD'     %create a new object loading a file
                    [pos,alpha,rectW] = loadRect(app);
                    if isempty(pos);return;end
                    PD.RectPos=pos;
                    PD.Xlimit=rectW;
                case 'RECTANGLE' %create a new object using given data
                    [pos,alpha,rectW] = newRect(PartData,app);
                    if isempty(pos);return;end
                    PD.RectPos=pos;
                    PD.Xlimit=rectW;
                case 'ROTATION'
                    alpha=varargin{1};
                case 'SUBDIVISION'
                    if app.SubdivisionButton.Value==0
                        PD.SubPoint='';
                        PD.SubVertices='';
                    else
                        PD.SubCol=app.ColEditField.Value;
                        PD.SubLin=app.LinesEditField.Value;
                        PD=subPoints(PD);
                    end
                    return;
            end
            PD.AngleRotation=alpha;
            PD.RotationMatrix=[cosd(alpha),sind(alpha);...
                -sind(alpha),cosd(alpha)];
            if doVert
                PD.Vertices = newVert(PD,alpha);
            end
            savePartialData(PD,app)
        end
        %Object functions
        function PD = grainListing(PD,gr)
            %GRAINSLISTING List of the grains that are inside the rectangle
            %   This function will find and write down the grains that are
            %   inside the chosen rectangle. Three diferent selections are
            %   made :  - GrainsInt : fully inside
            %           - GrainsRectangle : center inside
            %           - AllGrains : any part inside
            
            %reading Grains values
            R=gr.Radius;
            Y=gr.Coord(:,2);
            Z=gr.Coord(:,3);
            
            %Each grain can be defined by 5 points : center, topmost,
            %botbost, rightmost and left most
            Yp=Y+R;     Zp=Z+R;
            Ym=Y-R;     Zm=Z-R;
            %Center Check
            Vc=inpolygon(Y,Z,PD.Vertices(:,1),PD.Vertices(:,2));
            %Topmost check
            Vt=inpolygon(Y,Zp,PD.Vertices(:,1),PD.Vertices(:,2));
            %Botmost check
            Vb=inpolygon(Y,Zm,PD.Vertices(:,1),PD.Vertices(:,2));
            %Rightmost check
            Vr=inpolygon(Yp,Z,PD.Vertices(:,1),PD.Vertices(:,2));
            %Leftmost check
            Vl=inpolygon(Ym,Z,PD.Vertices(:,1),PD.Vertices(:,2));
            %total test
            testV=Vt+Vb+Vr+Vl;
            
            %First case
            %'Grains + radius' inside rectangle - first the grains that
            %have at least some part inside the rectangle. At least one of
            %the points must be inside of the rectangle
            allGr=gr.ID(testV>0);
            %Second case
            %Grains with center inside the  rectangle - grains that have
            %their center inside the rectangle.
            grRect=gr.ID(Vc);
            %Third Case
            %Grains that are completely inside the rectangle - all four
            %points presented above must be inside the rectangle.
            grInt=gr.ID(testV>3);
            
            %Xdimention
            rectX=PD.Xlimit/2; %Xlimit contains the entire lengh, half positive half negative
            if rectX>0
                X=gr.Coord(:,1);
                vXc=(abs(X)<=rectX);
                vXp=(abs(X)+R)<=rectX;
                vXm=(abs(X)-R)<=rectX;
                testV=(vXp)+(vXm);
                %First case
                grAll2=gr.ID(testV>0);
                %Second case
                grRect2=gr.ID(vXc);
                %Third case
                grInt2=gr.ID(testV>1);
                
                %intersect both values
                allGr=intersect(allGr,grAll2);
                grRect=intersect(grRect,grRect2);
                grInt=intersect(grInt,grInt2);
            end
            
            %Check for subdivision
            if ~isempty(PD.SubPoint)
                subGrains=cell(PD.SubLin*PD.SubCol,1);
                subGrainsI=cell(PD.SubLin*PD.SubCol,1);
                subGrainsA=cell(PD.SubLin*PD.SubCol,1);
                for i=1:(PD.SubLin*PD.SubCol)
                    %Checks
                    vCsub=inpolygon(Y,Z,PD.SubVertices(:,1,i),PD.SubVertices(:,2,i));
                    vTsub=inpolygon(Y,Zp,PD.SubVertices(:,1,i),PD.SubVertices(:,2,i));
                    vBsub=inpolygon(Y,Zm,PD.SubVertices(:,1,i),PD.SubVertices(:,2,i));
                    vRsub=inpolygon(Yp,Z,PD.SubVertices(:,1,i),PD.SubVertices(:,2,i));
                    vLsub=inpolygon(Ym,Z,PD.SubVertices(:,1,i),PD.SubVertices(:,2,i));
                    grSub=gr.ID(vCsub);
                    grSubI=gr.ID((vTsub+vBsub+vRsub+vLsub)>3);
                    grSubA=gr.ID((vTsub+vBsub+vRsub+vLsub)>0);
                    if rectX>0
                        grSub=intersect(grSub,grRect2);
                        grSubI=intersect(grSubI,grInt2);
                        grSubA=intersect(grSubA,grAll2);
                    end
                    subGrains{i}=grSub;
                    subGrainsI{i}=grSubI;
                    subGrainsA{i}=grSubA;
                end
                PD.SubGrains=subGrains;
                PD.SubGrainsI=subGrainsI;
                PD.SubGrainsA=subGrainsA;
            end
            
            %save values into the partialdatafile.
            PD.AllGrains = allGr;
            PD.GrainsRectangle = grRect;
            PD.GrainsInt = grInt;
        end       
        function PD = setRectpos(PD,mode,varargin)
            %SETRECTPOS setter to change the rectangle placement
            switch mode
                case 'LOAD'
                    pos = loadRect();
                    if isempty(pos);return;end
                    PD.RectPos=pos;
                case 'RECTANGLE'
                    pos = newRect(str2double(varargin{1}),string(varargin{2}),varargin{3:7});
                    if isempty(pos);return;end
            end
        end
        function Vs = newVert(PD,alpha)
            %NEWVERT calculates the new vertices of the rectangle aftr rotation
            %This function will be called by when there a change in the rotation angle
            %of the rectangle. This way we will calculate the new vertices of the
            %rectangle af  the rotation through the center.
            
            pos=PD.RectPos;
            RM=[cosd(alpha),sind(alpha);...
                -sind(alpha),cosd(alpha)];
            %Calculate the center of the rectangle on the common base
            R=pos(1:2)+pos(3:4)/2;
            %Vertices in the rotate base, in relation to the center of the
            %rectangle
            Vs=[-pos(3:4);-pos(3) pos(4);pos(3:4);pos(3) -pos(4)]/2;
            %rotate to the correct base
            Vs=Vs*RM';
            %translate back to the origin
            Vs=Vs+ones(4,2).*R;
        end
        function PD = subPoints(PD)
            %SUBP calculate the vertices points of the subdivision for the drawing
            %update everytime a value change
            
            %read partial data variables
            lMax=PD.SubLin;
            cMax=PD.SubCol;
            pos=PD.RectPos;
            RM=PD.RotationMatrix;
            
            %small calculations
            subL=pos(3)/cMax;           %subdivision length
            subH=pos(4)/lMax;           %subdivision height
            nbSub=lMax*cMax;            %total number of extra calculations per file
            subP=zeros(nbSub,2);       %contain the reference point and vertices  for the subdivisions
            
            %When making a rectangle, the rotation is calculated in relation to its
            %center. But the main point is the lower left corner before the
            %rotation. The following code calculates that point for each
            %subdivision taking into account the rotation.
            %
            %First we calculate the center of each subdivision in relation to the
            %center of the rectangle. Than we rotate it to the normal base.
            %Then we translate back to the origin of the system also removing half of
            %the subdivision height and width to we get the main point and not the
            %center in the correct base.
            %In the case of vertices (colum 3:10) we will do the same procces but
            %without removing the extra half of the subdivision.
            for l=1:lMax
                for c=1:cMax
                    %center calculation
                    subP(c+cMax*(l-1),:)=[(-pos(3)/2+(c-1/2)*subL)...
                        (pos(4)/2-(l-1/2)*subH)];
                end
            end
            %vertices calculation
            subV1=[subP(:,1)+subL/2 subP(:,2)-subH/2];
            subV2=[subP(:,1)+subL/2 subP(:,2)+subH/2];
            subV3=[subP(:,1)-subL/2 subP(:,2)+subH/2];
            subV4=[subP(:,1)-subL/2 subP(:,2)-subH/2];
            
            %Rotate back to the main axis in relation to the center of the main rectangle
            subP=subP*(RM)';
            subV1=subV1*(RM)';
            subV2=subV2*(RM)';
            subV3=subV3*(RM)';
            subV4=subV4*(RM)';
            
            %Translate back to the origin of the system
            subP=subP+[ones(nbSub,1)*(pos(1)+pos(3)/2-subL/2)...
                ones(nbSub,1)*(pos(2)+pos(4)/2-subH/2)];
            subV1=subV1+[ones(nbSub,1)*(pos(1)+pos(3)/2)...
                ones(nbSub,1)*(pos(2)+pos(4)/2)];
            subV2=subV2+[ones(nbSub,1)*(pos(1)+pos(3)/2)...
                ones(nbSub,1)*(pos(2)+pos(4)/2)];
            subV3=subV3+[ones(nbSub,1)*(pos(1)+pos(3)/2)...
                ones(nbSub,1)*(pos(2)+pos(4)/2)];
            subV4=subV4+[ones(nbSub,1)*(pos(1)+pos(3)/2)...
                ones(nbSub,1)*(pos(2)+pos(4)/2)];
            
            %prepare returning value, For now i have 5 [Nx2] matrixes, what would be
            %better is a 5x2xN.
            subV=cat(3,subV1,subV2,subV3,subV4,subV1); %Nx2x5 matrix
            subV=permute(subV,[3,2,1]); % 5x2xN.
            
            %Save values
            PD.SubPoint=subP;
            PD.SubVertices=subV;
            PD.SubL=subL;
            PD.SubH=subH;
        end
    end
end
%Support functions
function [pos,alpha,rectW] = newRect(PD,app)
            %NEWRECT creates a partData object following user's instructions
            %   This function will create a partData object  and save it in a file.
            %   Todo so an image will be created where the user will be able to reshape
            %   a ROI.RECTANGLE to select part of the image.
            
            boxY=app.boxYEF.Value;
            boxZ=app.boxZEF.Value;
            
            %check to witch TD step N1 belongs and load the correct values
            TD=app.TrialData;
            
            %Calculate Experiment walls for drawing
            row=(TD.Step==app.N1EF.Value); %row in wich STEP N1 is found
            height=boxZ+TD.Dz(row); %actual height of the piston
            Y=[TD.Dy1(row),TD.Dy1(row),(boxY+TD.Dy2(row)),(boxY+TD.Dy2(row)),TD.Dy1(row)];
            Z=[0,height,height,0,0];
            
            %Start data
            YN=0;alpha=0;pos=[(boxY)/2 0.05 boxY/2 boxZ/2]; %xmin ymin length heigth
            %Check for load data
            if ~isempty(PD)
                if ~isempty(PD.RectPos);pos=PD.RectPos;end
                if PD.AngleRotation~=0;alpha=PD.AngleRotation;end
            end
            %For now matlab cant use the axes generated by the matab app to draw ROI,
            %so we well create a new axes for that figure in wich we are going to draw.
            f=figure;
            plot(Y,Z,'k','LineWidth',3);
            axis equal;hold on
            ax=gca;
            %Start Calculation
            while YN~=1
                %Create Roi rectangle
                h =images.roi.Rectangle(ax,'Position',pos,...
                    'Rotatable',1,'RotationAngle',alpha);
                pause
                
                %Plot check data
                pos=h.Position;
                alpha=h.RotationAngle;
                vert=h.Vertices;
                delete(h);
                k=plot(ax,[vert(:,1);vert(1,1)],[vert(:,2);vert(1,2)],'b');
                %Ask if it is good
                answer2 = questdlg('Is the area (blue) well chosen?', ...
                    'Confirmation of area', ...
                    'Yes','No','Yes');
                if isequal('Yes',answer2); YN=1;end
                delete(k);
            end
            
            %Correct the rotation : for the calculations to work better we would want
            %the rotation angle to be in the interval ]-90,90[. A rectangle rotated of
            %90 degrees only means that it's height is actually its width and the orign
            %point need to be adjusted.
            if alpha>=90
                if alpha<180 %witdh and height needs to be reversed
                    alpha=alpha-90;
                    pos(1:2)=pos(1:2)+([pos(3)-pos(4),pos(4)-pos(3)])/2;
                    pos(3:4)=flip(pos(3:4));
                elseif alpha<270
                    alpha=alpha-180;
                else %witdh and height needs to be reversed
                    alpha=alpha-270;
                    pos(1:2)=pos(1:2)+([pos(3)-pos(4),pos(4)-pos(3)])/2;
                    pos(3:4)=flip(pos(3:4));
                end
            end
            %Check third dimension
            if app.Bool3D==3
                answer = questdlg(['Do you want to limit rectangle'...
                    ' width? (x direction)'],'Limit X','Yes','No','No');
                switch answer
                    case 'Yes'
                        asw = inputdlg(['Enter the rectangle width. For a value of 2a,'...
                            'x goes from -a to +a'],'Limit X',[1 35],string(app.boxXEF.Value));
                        rectW=str2double(asw{1});
                    case 'No';rectW=0;
                end
            else
                rectW=0;
            end
            delete(f);
            
        end
function [pos,alpha,rectW] = loadRect(app)
%LOADRECT prompt user to load existing rectangle file
%   Ask user where the file is found and create a partialData object using
%   the data that is written inside it.

OldF=cd;
try cd([app.SavePath '/MatlabResultsFile'])
catch
    cd(app.SavePath)
end

%loading rectangle file
[FileNameBase,PathNameBase,~] = uigetfile( ...
    {'*.txt','Text files(*.txt)';'*.*',  'All Files (*.*)'},'Select file for loading');

if FileNameBase==0 %check if we can load the file
    k=warndlg('No file was selected, please try again');pos='';alpha='';rectW='';
    waitfor(k);cd(OldF);return;
elseif sum(strfind(upper(FileNameBase),'RECTANGLE'))==0 %Check if file belongs to the right function
    k=warndlg('File selected does not match the function, please try again');
    cd(OldF);pos='';alpha='';rectW='';waitfor(k);return;
end

cd(PathNameBase);
opts = detectImportOptions(FileNameBase);
opts.DataLines = 4;
tab = readtable(FileNameBase,opts);
pos=tab{3,1:4};
alpha=tab{4,1};
rectW=tab{5,1};
cd(OldF);
end
function savePartialData(PD,app)
%Write down values
filename="Rectangle"+PD.RectPos(3)+"x"+PD.RectPos(4)+'rot'+PD.AngleRotation+'.txt';
fid = fopen(filename, 'w');
fprintf(fid, '## Data for Rectangle used for partial calculations ##\n');
fprintf(fid, '## First line is the Rectangle, second and third is the vertices ##\n');
fprintf(fid, '## (all y then all z), fourth is the rotation angle ##\n');
fprintf(fid, '%d %d %d %d\n',PD.Vertices(:,1)); %Vertices y
fprintf(fid, '%d %d %d %d\n',PD.Vertices(:,2)); %Vertices z
fprintf(fid, '%d %d %d %d\n',PD.RectPos);       %rect [y z width height]
fprintf(fid, '%d\n', PD.AngleRotation);         %rotation angle, rect center horary sens
fprintf(fid, '%d\n', PD.Xlimit);                %rectX width, 0 means all
fclose(fid);
FileMover(app,filename);
end


